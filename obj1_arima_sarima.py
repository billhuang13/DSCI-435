# -*- coding: utf-8 -*-
"""obj1_arima_sarima.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qeFWk3N0cYlB3cLax55cFM2OW9V2ntnR
"""

!pip install pmdarima

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pmdarima.arima import auto_arima
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error
from scipy import stats
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from itertools import product
from collections import defaultdict
from statsmodels.tsa.stattools import adfuller
import statsmodels.api as sm

import warnings
warnings.filterwarnings('ignore')

def data_split(df):
  train_size = int(len(df) * 0.8)
  train_data, test_data = df[:train_size], df[train_size:]
  return train_data, test_data

def rmse(actual, prediction):
  mse = mean_squared_error(actual, prediction)
  return np.sqrt(mse)

def arima_param(data, p_range = 12, q_range = 12):
  params = list(product(range(0,p_range,1), range(0,q_range,1)))
  aic_list = defaultdict(float)
  for p, q in params:
    try:
      model = sm.tsa.SARIMAX(data, order = (p,1,q)).fit()
      aic = model.aic
      aic_list[(p,1,q)] = aic
    except:
      continue

  aic_list = sorted(aic_list.items(), key = lambda x: x[1])
  p, d, q = aic_list[0][0]

  return p, d, q

def arima_model(data, p ,d, q):
  arima = sm.tsa.SARIMAX(data, order = (p,d,q)).fit()
  return arima

def sarima_param(data, p_range = 2, q_range = 2, P_range = 2, Q_range = 2, m = 9):
  params = list(product(range(0,p_range,1), range(0,q_range,1), range(0,P_range,1), range(0,Q_range,1)))
  aic_list = defaultdict(float)
  for p,q,P,Q in params:
    try:
      model = sm.tsa.SARIMAX(data, order = (p,1,q), seasonal_order = (P,1,Q,9)).fit()
      aic = model.aic
      aic_list[(p,1,q,P,1,Q)] = aic
    except:
      continue

  aic_list = sorted(aic_list.items(), key = lambda x: x[1])
  p,d,q,P,D,Q = aic_list[0][0]
  return p,d,q,P,D,Q

def sarima_model(data, p, d, q, P, D, Q, m=9):
  sarima = sm.tsa.SARIMAX(data, order = (p,d,q), seasonal_order = (P,D,Q,m)).fit()
  return sarima

def conf_int(data, confidence_level = 0.95):
  lower = []
  upper = []

  alpha = (1 - confidence_level) / 2
  z = (-1) * stats.norm.ppf(alpha)
  std_dev = data.std()
  margin = z * std_dev

  for i in range(len(data)):
    if data[i] - margin < 0:
      lower.append(0)
    else:
      lower.append(data[i] - margin)
    upper.append(data[i] + margin)

  lower = np.array(lower).flatten()
  upper = np.array(upper).flatten()

  return lower, upper

if __name__ == '__main__':
  df = pd.read_csv('monthly_data_06_23.csv')
  new_time = [i for i in range(108)] + [i for i in range(112, 139)]
  df = df.iloc[new_time, :].reset_index().drop(columns=['index'])
  # Dropping the year 2018 because it only has 4 data points
  # This will be better for our modeling for seasonality

  df

  call_counts = df['Call Count'].values
  call_counts
  # Extracting only the values of the target variable

  adfuller(call_counts)
  # ADF test on the variable

  adfuller(np.diff(call_counts, n=1))
  # The test finds that the time series becomes stationary after
  # differencing once

  train_df, test_df = data_split(call_counts)

  train_df

  test_df

  """### ARIMA model"""

  p, d, q = arima_param(train_df)

  p,d,q
  # The parameters that produce the lowest AIC value for the ARIMA
  # model turns out to be 10, 1, 0 for p, d, q respectively

  arima = arima_model(train_df, p, d, q)
  arima_pred = arima.get_prediction(109, 135).predicted_mean
  arima_pred
  # prediction for the testing set

  arima.plot_diagnostics(figsize=(8,6))
  plt.show()
  # residual plots for the ARIMA model

  arima_train_pred = arima.get_prediction(1,108).predicted_mean
  arima_train = rmse(arima_train_pred, train_df)
  # RMSE for the training set for the ARIMA model

  arima_test_pred = arima.get_prediction(109, 135).predicted_mean
  arima_test = rmse(arima_test_pred, test_df)
  # RMSE for the testing set for the ARIMA model

  arima_train, arima_test

  """### SARIMA model"""

  adfuller(np.diff(call_counts, n=9))
  # The ADF test shows that the time series becomes staionary after
  # differencing for one cycle, which is 9 observations in our case

  p,d,q,P,D,Q = sarima_param(train_df)

  p,d,q,P,D,Q
  # The most optimal parameters for the SARIMA model turns out to be
  # 0, 1, 1, 1, 1, 1 for p, d, q, P, D, Q respectively

  sarima = sarima_model(train_df,p,d,q,P,D,Q)
  sarima_pred = sarima.get_prediction(109, 135).predicted_mean
  sarima_pred
  # prediction for testing set from the SARIMA model

  sarima.plot_diagnostics(figsize=(8,6))
  plt.show()

  sarima_train_pred = sarima.get_prediction(1,108).predicted_mean
  sarima_train = rmse(sarima_train_pred, train_df)
  # RMSE for the training set for the ARIMA model

  sarima_test_pred = sarima.get_prediction(109, 135).predicted_mean
  sarima_test = rmse(sarima_test_pred, test_df)
  # RMSE for the testing set for the ARIMA model

  sarima_train, sarima_test

  """### Future Forecast"""

  future_year = ['2024-01', '2024-02', '2024-03', '2024-04', '2024-08', '2024-09', '2024-10', '2024-11', '2024-12',
                '2025-01', '2025-02', '2025-03', '2025-04', '2025-08', '2025-09', '2025-10', '2025-11', '2025-12',
                '2026-01', '2026-02', '2026-03', '2026-04', '2026-08', '2026-09', '2026-10', '2026-11', '2026-12']
  # The months for the next three years prediction

  arima_future = arima_model(call_counts,10,1,0)
  arima_future_pred = arima_future.get_prediction(136, 162).predicted_mean

  sarima_future = sarima_model(call_counts,0,1,1,1,1,1)
  sarima_future_pred = sarima_future.get_prediction(136, 162).predicted_mean

  # Creating a dataframe that contains all the actual call counts from existing data as well as the prediction for these data
  # from the two models
  new_df = pd.concat([pd.DataFrame({'Date': df['YearMonth'][:108],
                                    'Actual' : df['Call Count'][:108],
                                    'ARIMA': arima_train_pred,
                                    'SARIMA': sarima_train_pred}),
                    pd.DataFrame({'Date': df['YearMonth'][108:],
                                  'Actual': df['Call Count'][108:],
                                    'ARIMA': arima_pred,
                                    'SARIMA': sarima_pred})])

  new_df

  # Creating a different dataframe that contains future dates and future predictions from the two models
  new_df = pd.concat([new_df, pd.DataFrame({'Date': future_year,
                'ARIMA': arima_future_pred,
                'SARIMA': sarima_future_pred})]).reset_index().drop(columns=['index'])

  new_df

  plt.figure(figsize=(9.5, 6))

  plt.plot(new_df['Date'][:135], new_df['Actual'][:135], linewidth = 1.5, color = 'black')
  plt.plot(new_df['Date'], new_df['ARIMA'], linewidth = 1.5, color = 'red')
  plt.plot(new_df['Date'], new_df['SARIMA'], linewidth = 1.5, color = 'blue')


  plt.axvline(x = 108, color='gray', linestyle='dashed')
  plt.axvline(x = 135, color = 'gray', linestyle='dashed')

  plt.title('Comparison of time series predictions for the next 3 years', fontsize = 'large')
  plt.xlabel('Date', fontsize = 'large')
  plt.ylabel('Number of Call Counts', fontsize = 'large')

  plt.xticks(new_df['Date'][::9])
  plt.xticks(rotation=45)
  plt.legend(['Actual', 'ARIMA', 'SARIMA'],loc=0, frameon=True, fontsize='large') #prop = {"size":11}, loc=0, frameon=True)

  plt.show()
  # Plot with the actual data, the predictions from both ARIMA and SARIMA model, and the future forecasts